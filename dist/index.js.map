{
  "version": 3,
  "sources": ["../lib/index_of_types.js", "../lib/main.js", "../lib/index.js"],
  "sourcesContent": ["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Returns the first row index at which a given one-dimensional array of types can be found in a two-dimensional reference array of types (or `-1` if not found).\n*\n* ## Notes\n*\n* -   The intended use case for this function is for type dispatch (i.e., given a set of array data types, find a matching interface according the interface's accepted array data types).\n* -   The function assumes that `x` is stored in row-major order.\n* -   The function assumes that the number of indexed elements in `y` equals the number of columns in `x`.\n* -   The function returns a row index. To convert to a linear index, multiply `strideX1` by the return value.\n*\n* @private\n* @param {NonNegativeInteger} N - number of rows in `x` (size of first dimension)\n* @param {NonNegativeInteger} M - number of columns in `x` (size of second dimension)\n* @param {ArrayLikeObject} x - input two-dimensional reference array\n* @param {integer} strideX1 - `x` stride length along first dimension\n* @param {integer} strideX2 - `x` stride length along second dimension\n* @param {NonNegativeInteger} offsetX - `x` starting index\n* @param {ArrayLikeObject} y - search array\n* @param {integer} strideY - `y` stride length\n* @param {NonNegativeInteger} offsetY - `y` starting index\n* @returns {integer} row index (if found) and `-1` otherwise\n*\n* @example\n* // Define a reference array to search:\n* var types = [\n*     'float64', 'float64', 'float64',\n*     'float32', 'float32', 'float32',\n*     'uint32', 'uint32', 'float64',\n*     'int32', 'int32', 'float64',\n*     'uint16', 'uint16', 'float64',\n*     'int16', 'int16', 'float64',\n*     'uint8', 'uint8', 'float64',\n*     'int8', 'int8', 'float64'\n* ];\n*\n* // Define reference array dimensions:\n* var N = 8; // rows\n* var M = 3; // columns\n*\n* // Define a search array:\n* y1 = [\n*     'float32', 'float32', 'float32',\n* ];\n*\n* // Find the list of types:\n* var r1 = indexOfTypes( N, M, types, M, 1, 0, y1, 1, 0 );\n* // returns 1\n*\n// Define a search array:\n* y2 = [\n*     'float32', 'float32', 'float64',\n* ];\n*\n* // Find the list of types:\n* var r2 = indexOfTypes( N, M, types, M, 1, 0, y2, 1, 0 );\n* // returns -1\n*/\nfunction indexOfTypes( N, M, x, strideX1, strideX2, offsetX, y, strideY, offsetY ) { // eslint-disable-line max-len\n\tvar ix;\n\tvar iy;\n\tvar i;\n\tvar j;\n\n\t// Search for the first row which matches `y`...\n\tix = offsetX;\n\tfor ( i = 0; i < N; i++ ) {\n\t\tiy = offsetY;\n\t\tfor ( j = 0; j < M; j++ ) {\n\t\t\tif ( x[ ix+(j*strideX2) ] !== y[ iy ] ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tiy += strideY;\n\t\t}\n\t\t// If we successfully iterated over all columns, then that means we've found a match...\n\t\tif ( j === M ) {\n\t\t\treturn i;\n\t\t}\n\t\tix += strideX1;\n\t}\n\treturn -1;\n}\n\n\n// EXPORTS //\n\nmodule.exports = indexOfTypes;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar isNonNegativeInteger = require( '@stdlib/assert-is-nonnegative-integer' ).isPrimitive;\nvar isPositiveInteger = require( '@stdlib/assert-is-positive-integer' );\nvar isInteger = require( '@stdlib/assert-is-integer' ).isPrimitive;\nvar isFunctionArray = require( '@stdlib/assert-is-function-array' );\nvar isFunction = require( '@stdlib/assert-is-function' );\nvar isCollection = require( '@stdlib/assert-is-collection' );\nvar isndarrayLike = require( '@stdlib/assert-is-ndarray-like' );\nvar format = require( '@stdlib/string-format' );\nvar getDType = require( '@stdlib/ndarray-dtype' );\nvar resolveEnum = require( '@stdlib/ndarray-base-dtype-resolve-enum' );\nvar indexOfTypes = require( './index_of_types.js' );\n\n\n// FUNCTIONS //\n\n/**\n* Returns a list of data type enumeration constants.\n*\n* @private\n* @param {Collection} types - list of types\n* @returns {IntegerArray} list of data type enumeration constants\n*/\nfunction types2enums( types ) {\n\tvar out;\n\tvar i;\n\n\tout = [];\n\tfor ( i = 0; i < types.length; i++ ) {\n\t\tout.push( resolveEnum( types[ i ] ) );\n\t}\n\treturn out;\n}\n\n\n// MAIN //\n\n/**\n* Returns an ndarray function interface which accepts a callback function and performs multiple dispatch.\n*\n* @param {(FunctionArray|Function)} fcns - list of ndarray functions\n* @param {Collection} types - one-dimensional list of ndarray argument data types\n* @param {(Collection|null)} data - ndarray function data (e.g., function(s) to apply)\n* @param {PositiveInteger} nargs - total number of ndarray function interface arguments (including the callback function, but excluding the callback execution context)\n* @param {NonNegativeInteger} nin - number of input ndarrays\n* @param {NonNegativeInteger} nout - number of output ndarrays\n* @throws {TypeError} first argument must be either a function or an array of functions\n* @throws {TypeError} second argument must be an array-like object\n* @throws {TypeError} third argument must be an array-like object or `null`\n* @throws {Error} third and first arguments must have the same number of elements\n* @throws {TypeError} fourth argument must be a positive integer\n* @throws {TypeError} fifth argument must be a nonnegative integer\n* @throws {TypeError} sixth argument must be a nonnegative integer\n* @throws {Error} fourth argument must be compatible with the specified number of input and output arrays\n* @throws {Error} number of types must match the number of functions times the total number of array arguments for each function\n* @throws {Error} interface must accept at least one input and/or output ndarray\n* @returns {Function} ndarray function interface\n*\n* @example\n* var unaryBy = require( '@stdlib/ndarray-base-unary-by' );\n* var abs = require( '@stdlib/math-base-special-abs' );\n* var identity = require( '@stdlib/number-float64-base-identity' );\n* var Float64Array = require( '@stdlib/array-float64' );\n* var ndarray = require( '@stdlib/ndarray-ctor' );\n*\n* var types = [\n*     'float64', 'float64'\n* ];\n*\n* var data = [\n*     abs\n* ];\n*\n* var absolute = dispatchBy( unaryBy, types, data, 3, 1, 1 );\n*\n* // ...\n*\n* var xbuf = new Float64Array( [ -1.0, -2.0, -3.0, -4.0, -5.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* var x = ndarray( 'float64', xbuf, [ 5 ], [ 1 ], 0, 'row-major' );\n* var y = ndarray( 'float64', ybuf, [ 5 ], [ 1 ], 0, 'row-major' );\n*\n* absolute( x, y, identity );\n* // ybuf => <Float64Array>[ 1.0, 2.0, 3.0, 4.0, 5.0 ]\n*/\nfunction dispatchBy( fcns, types, data, nargs, nin, nout ) {\n\tvar narrays;\n\tvar nfcns;\n\tvar fcn;\n\n\tif ( isFunction( fcns ) ) {\n\t\tfcn = fcns;\n\t} else if ( !isFunctionArray( fcns ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be either a function or an array of functions. Value: `%s`.', fcns ) );\n\t}\n\tif ( !isCollection( types ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. Second argument must be an array-like object. Value: `%s`.', types ) );\n\t}\n\tif ( !isCollection( data ) && data !== null ) {\n\t\tthrow new TypeError( format( 'invalid argument. Third argument must be an array-like object or null. Value: `%s`.', data ) );\n\t}\n\tif ( !isPositiveInteger( nargs ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. Fourth argument must be a positive integer. Value: `%s`.', nargs ) );\n\t}\n\tif ( !isNonNegativeInteger( nin ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. Fifth argument must be a nonnegative integer. Value: `%s`.', nin ) );\n\t}\n\tif ( !isNonNegativeInteger( nout ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. Sixth argument must be a nonnegative integer. Value: `%s`.', nout ) );\n\t}\n\tnarrays = nin + nout;\n\tif ( narrays === 0 ) {\n\t\tthrow new Error( 'invalid arguments. Interface must accept at least one input and/or output ndarray. Based on the provided arguments, `nin+nout` equals `0`.' );\n\t}\n\tif ( nargs !== narrays+1 ) {\n\t\tthrow new Error( 'invalid arguments. Fourth argument is not compatible with the number of input and output ndarrays.' );\n\t}\n\tif ( fcn ) {\n\t\tnfcns = types.length / narrays;\n\t\tif ( !isInteger( nfcns ) ) {\n\t\t\tthrow new Error( 'invalid argument. Unexpected number of types. A type must be specified for each input and output ndarray for each provided ndarray function.' );\n\t\t}\n\t} else {\n\t\tnfcns = fcns.length;\n\t\tif ( types.length !== nfcns*narrays ) {\n\t\t\tthrow new Error( 'invalid argument. Unexpected number of types. A type must be specified for each input and output ndarray for each provided ndarray function.' );\n\t\t}\n\t}\n\tif ( data && data.length !== nfcns ) {\n\t\tthrow new Error( 'invalid argument. The third argument must have the same number of elements as the first argument.' );\n\t}\n\ttypes = types2enums( types );\n\treturn dispatcher;\n\n\t/**\n\t* ndarray function interface which performs multiple dispatch.\n\t*\n\t* @private\n\t* @param {ndarrayLike} x - ndarray\n\t* @param {...ndarrayLike} args - ndarray arguments\n\t* @param {Callback} clbk - callback function\n\t* @param {*} [thisArg] - callback function execution context\n\t* @throws {Error} insufficient arguments\n\t* @throws {Error} too many arguments\n\t* @throws {TypeError} input array arguments must be ndarray-like objects\n\t* @throws {TypeError} output array arguments must be ndarray-like objects\n\t* @throws {TypeError} unable to resolve an ndarray function supporting the provided ndarray argument data types\n\t* @throws {TypeError} callback argument must be a function\n\t* @returns {(ndarrayLike|Array<ndarrayLike>|void)} destination array(s)\n\t*/\n\tfunction dispatcher() {\n\t\tvar thisArg;\n\t\tvar arrays;\n\t\tvar dtypes;\n\t\tvar argc;\n\t\tvar clbk;\n\t\tvar idx;\n\t\tvar v;\n\t\tvar f;\n\t\tvar i;\n\n\t\targc = arguments.length;\n\t\tif ( argc !== nargs ) {\n\t\t\tif ( argc < nargs ) {\n\t\t\t\tthrow new Error( 'invalid invocation. Insufficient arguments.' );\n\t\t\t}\n\t\t\t// Check for a callback execution context argument...\n\t\t\tif ( argc === nargs+1 ) {\n\t\t\t\targc -= 1;\n\t\t\t\tthisArg = arguments[ argc ];\n\t\t\t} else {\n\t\t\t\tthrow new Error( 'invalid invocation. Too many arguments.' );\n\t\t\t}\n\t\t}\n\t\tclbk = arguments[ argc-1 ];\n\t\tif ( !isFunction( clbk ) ) {\n\t\t\tthrow new TypeError( format( 'invalid argument. Callback argument must be a function. Value: `%s`.', clbk ) );\n\t\t}\n\t\tarrays = [];\n\t\tdtypes = [];\n\t\tfor ( i = 0; i < narrays; i++ ) {\n\t\t\tv = arguments[ i ];\n\t\t\tif ( !isndarrayLike( v ) ) {\n\t\t\t\tif ( i < nin ) {\n\t\t\t\t\tthrow new TypeError( format( 'invalid argument. Input array must be an ndarray-like object. Value: `%s`.', v ) );\n\t\t\t\t} else {\n\t\t\t\t\tthrow new TypeError( format( 'invalid argument. Output array must be an ndarray-like object. Value: `%s`.', v ) );\n\t\t\t\t}\n\t\t\t}\n\t\t\tarrays.push( v );\n\t\t\tdtypes.push( resolveEnum( getDType( v ) ) );\n\t\t}\n\t\t// Resolve the ndarray function satisfying the input array types:\n\t\tidx = indexOfTypes( nfcns, narrays, types, narrays, 1, 0, dtypes, 1, 0 ); // eslint-disable-line max-len\n\n\t\t// Check whether we were able to successfully resolve an ndarray function:\n\t\tif ( idx < 0 ) {\n\t\t\tthrow new TypeError( 'invalid arguments. Unable to resolve an ndarray function supporting the provided array argument data types.' );\n\t\t}\n\t\t// Retrieve the ndarray function:\n\t\tif ( fcn ) {\n\t\t\tf = fcn;\n\t\t} else {\n\t\t\tf = fcns[ idx ];\n\t\t}\n\t\t// Evaluate the ndarray function:\n\t\tif ( data ) {\n\t\t\tf( arrays, data[ idx ], clbk, thisArg );\n\t\t} else {\n\t\t\tf( arrays, clbk, thisArg );\n\t\t}\n\t\tif ( nout === 1 ) {\n\t\t\treturn arrays[ narrays-1 ];\n\t\t}\n\t\tif ( nout === 0 ) {\n\t\t\treturn;\n\t\t}\n\t\treturn arrays.slice( nin );\n\t}\n}\n\n\n// EXPORTS //\n\nmodule.exports = dispatchBy;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Create an ndarray function interface which accepts a callback function and performs multiple dispatch.\n*\n* @module @stdlib/ndarray-dispatch-by\n*\n* @example\n* var ndarray = require( '@stdlib/ndarray-ctor' );\n* var unaryBy = require( '@stdlib/ndarray-base-unary-by' );\n* var abs = require( '@stdlib/math-base-special-abs' );\n* var identity = require( '@stdlib/number-float64-base-identity' );\n* var Float64Array = require( '@stdlib/array-float64' );\n* var dispatchBy = require( '@stdlib/ndarray-dispatch-by' );\n*\n* var types = [\n*     'float64', 'float64'\n* ];\n*\n* var data = [\n*     abs\n* ];\n*\n* var absolute = dispatchBy( unaryBy, types, data, 3, 1, 1 );\n*\n* // ...\n*\n* var xbuf = new Float64Array( [ -1.0, -2.0, -3.0, -4.0, -5.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* var x = ndarray( 'float64', xbuf, [ 5 ], [ 1 ], 0, 'row-major' );\n* var y = ndarray( 'float64', ybuf, [ 5 ], [ 1 ], 0, 'row-major' );\n*\n* absolute( x, y, identity );\n* // ybuf => <Float64Array>[ 1.0, 2.0, 3.0, 4.0, 5.0 ]\n*/\n\n// MODULES //\n\nvar main = require( './main.js' );\n\n\n// EXPORTS //\n\nmodule.exports = main;\n"],
  "mappings": "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",
  "names": ["require_index_of_types", "__commonJSMin", "exports", "module", "indexOfTypes", "N", "M", "x", "strideX1", "strideX2", "offsetX", "y", "strideY", "offsetY", "ix", "iy", "i", "j", "require_main", "__commonJSMin", "exports", "module", "isNonNegativeInteger", "isPositiveInteger", "isInteger", "isFunctionArray", "isFunction", "isCollection", "isndarrayLike", "format", "getDType", "resolveEnum", "indexOfTypes", "types2enums", "types", "out", "i", "dispatchBy", "fcns", "data", "nargs", "nin", "nout", "narrays", "nfcns", "fcn", "dispatcher", "thisArg", "arrays", "dtypes", "argc", "clbk", "idx", "v", "f", "main"]
}
